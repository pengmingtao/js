# Map是什么
// map????
// es6 新提出的一种引用类型的数据结构 类似于对象 
// 字符创-》值  值-》值 
## 声明Map数据结构
```javascript
const map = new Map()
const o = {p:'hello'} // 相当于键 key 
map.set(o,'content') // var a = {} a.name = '张三' a.name
console.log(map.get(o));
```
## 证明是引用数据类型
```javascript
// null 
typeof null 
const map = new Map()
console.log(map instanceof Map); // true 
console.log(Object.prototype.toString.call(map) === '[object Map]');
```
## 接收数组作为参数
```javascript
const map = new Map( [
        ['name','张三'],
        ['age',18]
    ])
    console.log(map.get('name')); // 张三
    console.log(map.get('age')); // 18
    // map 是数组的方法  Map 是es6新提出的一种新的 引用类型的数据结构
    const m = new Map(
        [
            [123,'abc'],
            ['a',{x:1,y:2}],
            [3>1,666]
        ]
    )
    console.log(m.get(true)); // 666
    // 404 Not found 500 InterError 404和500 都是数值
    let errors = new Map([
        [404,'Not found'],
        [500,'InterError']
    ])
    // 注意 对象作为键名 传输的是地址
    // let m1 = new Map([
    //     [123,'abc'],
    //     [{x:1},'cdf']
    // ])
    // console.log(m1.get({x:1})); // undefined
    let obj1 = {x:1}
    let m1 = new Map([
        [123,'abc'],
        [obj1,'cdf']
    ])
    console.log(m1.get(obj1)); // cdf
```
## Map接收数组作为参数的本质
```javascript
// 为什么 接收一个二元数组 key value的形式 就可以通过 map.get()获取到值呢
const array = [
    ['name','张三'],
    ['age',18]
]
const map = new Map()
array.forEach(
    ([key,value])=>map.set(key,value)
)
```
## Map参数的扩展
```javascript
// 具有迭代器 iterator 接口 每个成员都是双元素的数组的数据结构 都可以当做map构造函数的参数
```
# Iterator 和 for...of 循环
## 为什么要有iterator？？
```javascript
// Map Set 等数据结构 需要一个统一的接口去处理 iterator就是提供了这么一个机制
```
## 作用
```javascript
// 数据部署了iterator接口 就可以用for ... of 循环遍历
```
## for...of 循环的遍历过程的本质
```javascript
// for...of 循环遍历的过程
    // 1 创建一个指针对象 指向数据的初始位置 iterator就是一个指针对象
    // 2 第一次调用指针对象的next() 可以将指针指向第一个成员
    // .....
    // 直到结束
    // !!!! 每一次调用指针对象的时候每次调用next()方法 会返回 value 指的是值 done是布尔值 用来标识遍历是否完成
    const arr = [1,2]
    function makeIterator(array){
        let nextIndex = 0;
        return {
            next:function(){
                return nextIndex < array.length ? {
                    value:array[nextIndex++],
                    done:false
                } :{
                    value:undefined,
                    done:true
                }
            }
        }
    }
    let res = makeIterator(arr)
    console.log(res.next());
    console.log(res.next());
    console.log(res.next());
    console.log(res.next());
```
## Iterator接口部署在数据结构的Symbol.iterator属性 
```javascript
// 重中之重
let arr1 = [1,2,3,4,5]
    // let iter = arr1[Symbol.iterator]()
    // console.log(iter.next());
    // console.log(iter.next());
    // console.log(iter.next());
    // console.log(iter.next());
    // console.log(iter.next());
    // console.log(iter.next());
    // console.log(iter.next());
    // console.log(iter.next());
    // console.log(iter.next());
```
## 原生具备Iterator接口的数据结构 
```javascript
具有iterator接口 Array Map Set String 
```
## 对象不具备Iterator接口 可以手动部署迭代器接口 让其可以用for...of 循环遍历
```javascript
// 想让对象也可以通过for...of 循环遍历
    let obj = {
        data:[1,2,3,4],
        [Symbol.iterator](){
            let index = 0
            let that = this
            return {
                next(){
                    if(index<that.data.length){
                        return {
                            value:that.data[index++],
                            done:false
                        }
                    }else{
                        return {
                            value:undefined,
                            done:true
                        }
                    }
                }
            }
        }
    }

    for (let i of obj ){
        console.log(i);
    }
```
# 函数扩展
## 函数参数的默认值

## 与结构赋值结合的使用

## 参数默认值会形成单独的作用域

## 参数展开运算符打包

## 函数内部严格模式的改变































