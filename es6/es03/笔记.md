# 对象的扩展方法
## 属性的简写
```javascript
const a = 'a';
const obj = {a}
// const obj = {a:a}
console.log(obj);
```
## 方法的简写
```javascript
 const o = {
        say(){
            return '我是chris'
        }
    }
    console.log(o.say());
    // 谁用我我就指向谁
    var name = '全局'
    const person = {
        name:'张三',
        say(){
            console.log(`我的名字是${this.name}`);
        }
    }
    person.say()
    let res = person.say; // 全局
    res()
```
## 属性名表达式
```javascript
let obj1 = {
        // 让属性和变量挂钩
        [key]:true,
        ['o'+'b']:123,
        [`ok`]:456
    }

    console.log(obj1);
```
## super 关键字
```javascript
const proto = {
        foo:'土豆'
    }

    // const oProto = {
    //     foo:'西红柿',
    //     find(){
    //         return super.foo
    //     }
    // }

    // // proto 是 oProto的原型
    // Object.setPrototypeOf(oProto,proto) // __proto__
    // console.log(oProto.find()); // 

    // const oProto = {
    //     foo:super.foo
    // }

```
### 对象的扩展运算符 ...
#### 打包
```javascript
 // 打包
    // let {x,y:y,...z} = {x:1,y:2,a:3,b:4}
    // console.log(z);
    // 等号的右边必须是一个对象 
    // let {...h} = undefined
    // let {...v} = null
    // 数组的解构赋值 ... 有一个注意点 是...的位置
    // let {...z,x,y} = {x:1,y:2,a:3,b:4}
```
#### 拆包
```javascript
 // 复制 浅拷贝 深拷贝
    // 数组的浅拷贝es5 用到的是什么  concat
    // 对象的扩展运算符 ...也是浅拷贝 
    // 复制 
    // let obj = {a:1}
    // // let obj1 = obj;
    // // obj1.a = 2;
    // // console.log(obj);
    // // 浅拷贝
    // let obj1 = {...obj}
    // obj1.a = 2;
    // console.log(obj);
    // // es5 实现浅拷贝 类比concat 
    // let person = {name:'张三',age:12}
    // let person2 = Object.assign({},person)
    // person2.name = '王五'
    // console.log(person);

    // let {a,b,...z} = {c:1,b:2,a:3,d:4}
    // console.log(z);
    // 是不是深拷贝？ 不是！！！ 
    let obj = {a:{b:1}}
    let obj1 = {...obj}
    obj1.a.b =2;
    console.log(obj);
```
# Symbol数据结构
## 概念以及引入的原因
```javascript
 // 新提出的一个数据结构 Symbol 基本数据类型
    // Symbol表示独一无二 第七种数据类型
    // 作用？ 
    // 对象的属性是字符串 对象的话隐式调用toString 转化成字符串
    let a = {a:1};
    let b = {b:2};
    let c = {};
    c[a] = 3; // [object Object]
    c[b] = 4; // [object Object]
    console.log(c);
    // ? 怎么解决 
    let s = Symbol()
    console.log(typeof s); // 第七种一般数据类型
```
## 接收字符串作为参数
```javascript
let s1 = Symbol('a')
    let s2 = Symbol('b')
    console.log(s1);
    console.log(s2);
    console.log(s1.toString());
    console.log(s2.toString());
    let s3 = Symbol({})
    console.log(s3);
    // 传入的参数只是值得描述 即使传入的值是一样的 返回值也是不相等的
    let s4 = Symbol()
    let s5 = Symbol();
    console.log(s4 === s5);
    let s6 = Symbol('a')
    let s7 = Symbol('a');
    console.log(s6 === s7);
```
## 不能与其他类型的值进行计算
```javascript
let sym = Symbol('my Symbol')
    'my symbol is' + sym
```
## Symbol可以显示转化为字符串
```javascript
    let s1 = Symbol('a')
    let s2 = Symbol('b')
    console.log(s1);
    console.log(s2);
    console.log(s1.toString());
    console.log(String(s1));
```
## Symbol可以转为布尔值 但是不能转化成数值
```javascript
    let symb = Symbol();
   console.log( !Boolean(symb));
```
## Symbol.iterator 属性
```javascript
对象的Symbol.iterator属性 指向该对象的默认遍历器的方法 for...of 循环的时候会调用Symbol.iterator
```
## Object.getOwnPropertySymbols()
```javascript
const obj = {};
   let sym1 = Symbol('a')
   let sym2 = Symbol('b')
   obj[sym1] = 'hello'
   obj[sym2] = 'world'
   // Object.getOwnPropertySymbols() 返回一个数组 里面的值是所有用作属性名的Symbol的值
   const arr = Object.getOwnPropertySymbols(obj)
   console.log(arr);
```
## 作用实例 常量枚举 私有属性
```javascript

//    // js没有枚举类型 用到枚举案例的时候可以用到 Symbol类型
   
//    const CODE_ONE = 1; // 汽车的颜色 红色
//    const CODE_TWO = 1;// 蓝色
//    const CODE_THREE = 3;// 黑色

//    const CODE_ONE = Symbol('a'); // 汽车的颜色 红色
//    const CODE_TWO = Symbol('b');// 蓝色
//    const CODE_THREE = Symbol('b');// 黑色

//    // 会实现私有属性
   const private = Symbol('private')
   const obj = {
       // 私有属性
        _name:'张三',
        [private]:'私有的属性'
   }

   console.log(Object.keys(obj));
   // 到底怎么实现私有属性呢？ class  里面的一些东西 会详细讲到
```
# Set数据结构
## Set是什么
```javascript
// Set是es6新提出的一个新的引用数据类型 类似于数组 但是成员是唯一的 没有重复的值
    // 和对象里面的 get  set 不一样
```
## 基本用法
```javascript
// 基本用法
    const set = new Set([1,2,3,4,5,6,5])
    console.log(set);
```
## 证明set是js新的引用数据类型
```javascript
    let arr = [1,2,3,4]
    let obj = {name:'张三'}
    let nu = null // 历史遗留问题
    console.log(typeof arr);
    console.log(typeof obj);
    console.log(typeof nu);
    
    // 证明 arr是数组  obj 是对象

    // instanceof 
    // Object.prototype.toString.call(arr)

    console.log(arr instanceof Array);
    console.log(obj instanceof Object);
    console.log(Object.prototype.toString.call(arr)); // string [object Array]
    console.log(Object.prototype.toString.call(obj)); // string [object Object]

    const set = new Set([1,2,3,4,5,6,5])
    console.log(set instanceof Set);
    console.log(Object.prototype.toString.call(set) === '[object Set]');
```
## 转化成数组
```javascript
// 转化成数组
    const set = new Set([1,2,3,4,5,6,5])
    
    // 数组去重的方法
    console.log([...set]);
    console.log(Array.from(set));
```
## Set数据内部判断值得机制
```javascript
// Set数据内部判断值得机制 类似于 === 
    let newSet = new Set()
    let a = 5;
    let b = '5'
    newSet.add(a)
    newSet.add(b)
    // ? 里面有几项 ？
    console.log(newSet);
    // 特殊情况NaN 
    // 因为 NaN === NaN 
    newSet.add(NaN)
    newSet.add(NaN)
    console.log(newSet);
```
## Set实例的属性和方法
### Set的属性
```javascript
let lastSet = new Set()

lastSet.add(1).add(2).add(2).add('2').add(NaN).add(NaN)

console.log(lastSet.size);
    
```
### add delete has clear
```javascript
 let lastSet = new Set()
    lastSet.add(1).add(2).add(2).add('2').add(NaN).add(NaN)
    console.log(lastSet.size);
    // 判断是否有这一项
    console.log(lastSet.has(2));
    lastSet.clear()
    console.log(lastSet);
    
```
### 方法forEach()
```javascript
```

## Map数据结构
### Map是什么？

### 怎么声明Map数据结构

### 证明是引用的数据类型

### 比较之前的对象

### 接收数组作为参数

### 注意传值传地址特点

### 接收数组的本质

### map参数的扩展

# 作业
### Set和展开运算符实现数组的交集 并集 差集
```javascript
let arr1 = [1,2,3]
let arr2 = [4,3,2]

// this题
let a = '全局'
    let obj1 = {
        a:"局部",
        say:function(){
            console.log(this.a);
        }
    }
    obj1.say()
    let res = obj1.say;
    res()
    let obj2 = {
        a:'局部2',
        say:function(fn){
            fn()
        }
    }

    obj2.say(obj1.say)

    obj2.say = obj1.say

    obj2.say()
```



