# 1. es6的背景介绍
ES6是什么？
ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了
和js之间的关系
ECMAScript是JavaScript语言的国际标准，JavaScript是ECMAScript的实现。
作用
是使得JavaScript语言可以用来编写大型的复杂的应用程序，成为企业级开发语言。（更具模块化） 
# 2. let const var
## 2.1. 不存在变量提升
```javascript
    // es5
    // 1 全程扫描一下错误 2 预编译环节
    console.log(a); // undefined
    var a = 123
    // es6 
    console.log(b);
    let b = 456;
    console.log(b);
```
## 2.2. 暂时性死区
### 2.2.1. let死区
```javascript
    var tep = 890;
    if(true){
        tep = 'abc'
        let tep
    }
```
### 2.2.2. typeof 不再是百分百报错
```javascript
    // typeof 不再是完全正确的
    console.log(typeof c);
    let c;
```
### 2.2.3. 不允许重复声明
```javascript
    let e = 123;
    let e = 456
    // 'e' has already been declared
```
## 2.3. 块级作用域
### 2.3.1. 为什么要有块级作用域？
```javascript
     // 内层的变量会覆盖外层的变量
    var a = '全局'
    function fn(){
        // 预编译 找var a
        // var a
        console.log(a); // undefined
        if(false){
            var a = '局部'
        }
    }
    fn()
    // 复习预编译的东西
    // 全局  函数作用  块级作用域（在各自的块干自己的事情 不影响）
    var a = '全局';
    (function(){
        var a = '局部'
        console.log(a);
        
    }())
    console.log(a)
     let a = '全局'
    {
        let a = '局部'
        console.log(a);
    }
    console.log(a);
```
### 2.3.2. 允许作用域的任意嵌套
```javascript
    // 允许作用域的任意嵌套
    {
        {
            let b = '局部'
        }
        console.log(b); // b is not defined
    }
    {
        {
            let b = '局部'
            {
                console.log(b);
            }
        }
    }
```
### 2.3.3. 注意
```javascript
    if(true){
        let x = 1;
    } // 不会报错

    if(true) let y = 2 // 会报错
    // Lexical declaration cannot appear in a single-statement context
```

### 2.3.4. 开发中具体的例子

## 2.4. const 特殊的地方
### 2.4.1. 声明常量不能变
```javascript
    const a = 123;
    a = '123'
    const b = true;
    b = false
```
### 2.4.2. 本质
```javascript
    // 引用数据类型可以变变得是堆里面的内容 不变的是地址

    const obj = {name:'chris',age:33}
            
    console.log(obj);

    obj = {name:'Chris',age:33}
```
### 2.4.3. 可以冻结对象
```javascript
    // const foo = Object.freeze({})
    // foo.name = '大白菜'
    // console.log(foo);
    'use strict'
    const foo = Object.freeze({})
    foo.name = '大白菜'
```
## 2.5. 全局的缺陷
```javascript
     // new Array()
    console.log(window.Array);
    var Array = '这是数组'
    console.log(window.Array);
    
    var a = '123'
    console.log(window.a); // 123
    
    let b = '全局'
    console.log(window.b); // undefined
    // let 提出后 全局变量和顶层对象的属性 脱钩
```
# 3. 解构赋值
## 3.1. 数组解构赋值
```javascript
    // 通过数组对变量进行赋值
    let arr = [1,2,3]
    console.log(arr[0]);
    console.log(arr[1]);
    console.log(arr[2]);
    let [a,b,c] = [1,2,3]
    console.log(a);
    console.log(b);
    console.log(c);
    
```
### 3.1.1. 模式匹配
等号两边的模式相同 左边的变量就会被赋予对应的值
```javascript
  let [a,[[b],c]] = [1,[[2],3]]
    console.log(a);
    console.log(b);
    console.log(c);
```
### 3.1.2. 不完全解构
```javascript
// 不完全解构
    let [x,y,u] = [1,2,3,4]
    console.log(x);
    console.log(y);
    console.log(u);
```
### 3.1.3. 嵌套模式
```javascript
  let [a,[[b],c]] = [1,[[2],3]]
    console.log(a);
    console.log(b);
    console.log(c);
```
### 3.1.4. 默认值
```javascript
 // 指定默认值
    let [f = true] = []
    console.log(f);
    let [a,b="y"] = ['a']
    console.log(b);
    // 注意点 es6内部使用 === 判断是否是undefined 如果是undefined 默认值才会生效
    let [x = 1] = [null]
    let [y = 2] = [undefined]
    console.log(x); // null 
    console.log(y); // 2
```
#### 3.1.4.1. 惰性求值
```javascript
// 惰性求值
    function f(){
        return 'fff'
    }
    // let [x = f()] = [1]
    let [x = f()] = []
    console.log(x);
```
#### 3.1.4.2. 默认值可以引用解构赋值的其他变量
```javascript
// 默认值可以引用解构赋值的其它变量 前提是变量必须已经声明
    // let [x= 1,y=x] = []
    // console.log(x); // 1 
    // console.log(y);
    // let [x = y,y=1] = [] // 从左往右
    // let [y = 1 , x = y] = []
    // console.log(x);
    // console.log(y);
```
## 3.2. 对象解构赋值
### 3.2.1. 定义用法注意点
```javascript
 let person = {
        name:"chris",
        age:33
    }
    // let {name,age} = person;
    // 注意：对象的解构和数组不一样  和顺序无关
    let {age:age,name:name} = person;
    console.log(name);
    console.log(age);
    
    let {sex} = person;
    console.log(sex); // 解构不成功会返回undefined
    // 真正被赋值的是后者 对象解构赋值的实质
    // 会先找到同名的属性 赋值给后者的变量
    let {name:name1} = person
    console.log(name1);
```
### 3.2.2. 可以取到继承的属性
```javascript
    const obj1 = {};
    const obj2 = {name:'laney'}
    Object.setPrototypeOf(obj1,obj2)
    // obj1.__proto__ = obj2
    const {name} = obj1;
    console.log(name);
```
### 3.2.3. 指定默认值
```javascript
// 默认值的生效条件 对象属性的值 严格 === undefined
const {x = 1} = {x:undefined}
const {y = 3} = {y:null}
console.log(x);
console.log(y);
```

# 作业
```javascript
// 练习题
    const items = [
        ['name','张飞'],
        ['title','长坂坡一声吼']
    ]
    // 循环数组  分别打印 第二层数组的值 用数组的解构来做
```













