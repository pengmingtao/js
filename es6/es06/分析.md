# 箭头函数不适用的场景
```javascript
见文件
```
# class类
## 是什么？
* es6新提供的一种生成对象实例的写法 es5构造函数的另外一种写法（语法糖）
## 作用
* 无疑让写法更清晰 更像面向对象的写法
## 回顾之前es5生成实例对象
```javascript
Person.prototype.say = function(){
        console.log('我会说话');
        
    }
    // 这是错误的写法
    // Person.prototype.say = ()=>{
    //     console.log(`我是${this.name}`);
    // }
    function Person(name,age){
        this.name = name
        this.age  = age
    }

    let person1 = new Person('张三',18)
    person1.say()
```
## class类生成实例对象
```javascript
class Person{
        constructor(name,age){
            this.name = name
            this.age = age
        }

        say(){
            console.log(`我是${this.name}`); 
        }
    }

    let person2 = new Person('李四',20)
    person2.say()

    console.log(typeof Person); // function
    console.log(person2.constructor === Person);
```
## constructor 方法
```javascript
// es6类的方法都定义在类的prototype属性上面
    // 其实调用es6类的方法就是调用原型上的方法
    // class Car{
    //     constructor(){}
    // }

    // // 类似于
    // // Car.prototype = {
    // //     constructor(){}
    // // }

    // let bmw = new Car()
    // console.log(bmw.constructor === Car.prototype.constructor);
    // // 一次性在类里面添加多个方法 ？？？
    // Object.assign(Car.prototype,{toValue(){}})
    // constructor

    // 是类默认的方法 只要通过new来生成 就会自动调用这个方法 如果你不写也存在 
    // 一个类必须要有constructor方法
    // class Car{
       
    // }
    // // 相当于
    // class Car{
    //     constructor(){}
    // }

    class Car{
        constructor(){
            console.log(this);
            // 指向其他的对象  null 
            return Object.create(null)
        }
    }

    let bmw = new Car()
    console.log(bmw instanceof Car) // 
```
## 共享一个原型对象
```javascript
 class Person{
        constructor(name) {
            this.name = name
        }
        
    }
    Person.prototype.get = function(){
        console.log('我是父类')
    }

    let person1 = new Person('张三')
    let person2 = new Person('李四')

    person1.get()
    person2.get()

```
## 取值函数和存值函数
```javascript
 const person = {
        get name(){
            console.log(name);
            return name
        },
        set name(value){
            console.log(value);
            name = value
        }
    }

    person.name = 'tony'
    // console.log();
    console.log(person.name);
    class MyClass{
        get prop(){
            return MyClass.prop
        }
        set prop(value){
            // ????
            MyClass.prop = value
        }
    }
    
    let init = new MyClass()
    init.prop = 123
    console.log(init.prop);
    
```
## this指向问题
```javascript
class Person{
        constructor(){
            this.eat = this.eat.bind(this)
        }
        eat(){
            // 调用get
            this.get()
        }
       
        // eat = ()=>{
        //     this.get()
        // }
        get(){
            console.log('这是食物');
        }
            
    }
    let person1 = new Person()
    // person1.eat()

    let {eat} = person1
    // let eat = person1.eat
    eat() // ???? 不会输出 ???怎么解决呢？？？
    // 第一种 箭头函数
    // eat = ()=>{
    //         this.get()
    //     }

    // 第二种
    // constructor(){
    //         this.eat = this.eat.bind(this)
    //     }
    // 第三种  proxy 留着讲完了proxy之后讲解


    // class Person{

    // }
    // Person.prototype.get = function(){
    //     console.log('这是食物');
        
    // }

    // Person.prototype.eat = function(){
    //     console.log(this);
    //     this.get()
    // }

    // let person1 = new Person()

    // let {eat} = person1
    // // let eat = person1.eat
    // eat() // ???? 不会输出
```
## 实例属性的新写法
```javascript
    // class Person{
    //     name = 'tony'
    // }
```
## 静态属性
```javascript
// 静态属性 指的是class本身的属性 Class.propname 并不是实例的属性
    // class Person{
    //     static age = 18 // 现在静态属性的写法
    //     name = 'tony'

    // }
    // let person1 = new Person()  
    // console.log(person1.age);// undefined
```
## 静态方法
```javascript
// 静态方法

    class Person{
        static age = 18 // 现在静态属性的写法
        static say(){
            console.log('hello');
             
        }
        name = 'tony'

    }
    // let person1 = new Person()  
    Person.say()
```
## 私有属性
### 以前用闭包实现私有属性
```javascript

    // 指的是是能在类的内部使用 不能再类的外部使用
    // ??es5 的闭包实现私有属性你们知道不

    class Math{
        #count = 0
        add(){
            this.#count ++;
            return this.#count
        }
    }

    let math = new Math()
    // console.log(math.#count); 会报错

    console.log(math.add());
```
## 私有方法
```javascript
 class MathAdd{
       #a;
       #b;
       constructor(){
           this.#a = 1;
           this.#b = 2;
       }
       #sum = ()=>{
           return this.#a + this.#b
       }
        conSum(){
            console.log(this.#sum());
            
        }
    }

    let mathadd = new MathAdd()
    // console.log(math.#count); 会报错
    mathadd.conSum()
```
# class类的继承
```javascript

```
## extends
```javascript

```
## super
```javascript

```