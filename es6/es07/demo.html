<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>class继承</title>
</head>
<body>
    <script>
        //class 通过extends关键字继承
        // class Father{
        //     ss='sssssssss'
        //     constructor(){
        //         this.name='父类'
        //         this.age=12
        //     }
        //     work(){
        //         console.log("我是父类")
        //     }
        // }
        // class Children extends Father{
        //     ss="ffffffff"
        //     constructor(name){
        //         super();
        //         console.log(this)
        //         this.name=name
        //     }
        // }
        // let child =new Children('cherry');
        // console.log(child.name)
        // console.log(child.age)
        // console.log(child.ss)  //ffffffff 先找自己的 自己找不到 再找父类
        // console.log(child.work())

        //super 关键字
        //继承必须要在子类的constructor中调用super() (constructor的第一行,否则会报错)
        //原因是子类自己的this对象必须通过父类的构造函数生成
        //不调用super 子类拿不到this 对象
        //super() 只能在构造函数中使用
        // class Father{
        //     constructor(){
        //         this.name="父类"
        //     }
        //     work(){
        //         console.log('我是父类')
        //         return 'w'
        //     }
        // }
        // class Children extends Father{
        //     constructor(name){
        //         super()
        //         this.name=name
        //     }
        //     // fn(){
        //     //     super() //这种写法是错误的 super() 只能在构造函数中
        //     // }
        // }
        // let c =new Children('cherry')
        // console.log(c.name)
        // console.log(c.work()) 

        //super 作为对象在普通方法中指向父类的  !!!!原型对象!!!
        // class A {
        //     pA=123  //是class类/实例的属性 不是原型属性
        //     p(){
        //         return 3
        //     }
        // }
        // A.prototype.pA=5 //A的原型属性
        // class B extends A{
        //     constructor(){
        //         super()
        //         console.log(super.p()) //3
        //         console.log(super.pA) //super 指向A父类的原型对象 输出123
        //     }
        //     fn (){
        //         console.log(super.p()) //3
        //     }
        // }
        // let b=new B()
        // console.log(b.pA) //123
        // b.fn() //3
        
        //调用super后内部的this指向子类的实例 (如果子类的实例找不到 会找父类的,父类找不到会是undefined)
        // class A{
        //     constructor(){
        //         this.x=1
        //         this.p=12
        //     }
        //     print(){
        //         console.log(this.p)
        //     }
        // }
        // class B extends A{p
        //     constructor(p){
        //         super()
        //         this.p=p
        //     }
        //     fn(){
        //         super.print()
        //         //相当于es里面的super.print.call(this)
        //     }
        // }
        // let b=new B(10)
        // b.fn() //10

        //通过super对属性赋值 这时的super 相当于this
        // class A{
        //     constructor(){
        //         this.x=1;
        //     }
        // }
        // // A.prototype.x=222222
        // class B extends A{
        //     constructor(){
        //         super()
        //         this.x=2
        //         super.x=3  //相当于this.x=3
        //         console.log(super.x)  //super 作为对象在普通方法中指向父类的 原型对象 输出undefined
        //         console.log(this.x)
        //     }
        // }
        // let b=new B()

        //super 作为对象在静态方法中 指向父类而不是原型对象
        // class A{
        //     static myMethod(msg){
        //         console.log(`静态-${msg}`)
        //     }
        //     myMethod(msg){
        //         console.log(`普通-${msg}`)
        //     }
        // }
        // class B extends A{
        //     static myMethod(msg){
        //         super.myMethod(msg)
        //     }
        //     myMethod(msg){
        //         super.myMethod(msg)
        //     }
        // }
        // B.myMethod(1)
        // let b=new B();
        // b.myMethod(2)

        //子类的静态方法中通过super调用父类的方法时
        //方法内部的this指向当前的子类 而不是子类的实例
        class A{
            constructor(){
                this.x=1
            }
            static print(){
                console.log(this.x)
            }
        }

        class B extends A{
            constructor(){
                super()
                this.x=2
            }
            static fn(){
                super.print()
            }
        }
        
        B.x=30
        B.fn()


    </script>
</body>
</html>